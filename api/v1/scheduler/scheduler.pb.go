// Code generated by protoc-gen-go. DO NOT EDIT.
// source: scheduler.proto

/*
Package scheduler is a generated protocol buffer package.

It is generated from these files:
	scheduler.proto

It has these top-level messages:
	Event
	FrameworkID
	MasterInfo
	Address
	DomainInfo
*/
package scheduler

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Possible event types, followed by message definitions if
// applicable.
type Event_Type int32

const (
	// This must be the first enum value in this list, to
	// ensure that if 'type' is not set, the default value
	// is UNKNOWN. This enables enum values to be added
	// in a backwards-compatible way. See: MESOS-4997.
	Event_UNKNOWN               Event_Type = 0
	Event_SUBSCRIBED            Event_Type = 1
	Event_OFFERS                Event_Type = 2
	Event_INVERSE_OFFERS        Event_Type = 9
	Event_RESCIND               Event_Type = 3
	Event_RESCIND_INVERSE_OFFER Event_Type = 10
	Event_UPDATE                Event_Type = 4
	Event_MESSAGE               Event_Type = 5
	Event_FAILURE               Event_Type = 6
	Event_ERROR                 Event_Type = 7
	// Periodic message sent by the Mesos master according to
	// 'Subscribed.heartbeat_interval_seconds'. If the scheduler does
	// not receive any events (including heartbeats) for an extended
	// period of time (e.g., 5 x heartbeat_interval_seconds), there is
	// likely a network partition. In such a case the scheduler should
	// close the existing subscription connection and resubscribe
	// using a backoff strategy.
	Event_HEARTBEAT Event_Type = 8
)

var Event_Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "SUBSCRIBED",
	2:  "OFFERS",
	9:  "INVERSE_OFFERS",
	3:  "RESCIND",
	10: "RESCIND_INVERSE_OFFER",
	4:  "UPDATE",
	5:  "MESSAGE",
	6:  "FAILURE",
	7:  "ERROR",
	8:  "HEARTBEAT",
}
var Event_Type_value = map[string]int32{
	"UNKNOWN":               0,
	"SUBSCRIBED":            1,
	"OFFERS":                2,
	"INVERSE_OFFERS":        9,
	"RESCIND":               3,
	"RESCIND_INVERSE_OFFER": 10,
	"UPDATE":                4,
	"MESSAGE":               5,
	"FAILURE":               6,
	"ERROR":                 7,
	"HEARTBEAT":             8,
}

func (x Event_Type) Enum() *Event_Type {
	p := new(Event_Type)
	*p = x
	return p
}
func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (x *Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_Type_value, data, "Event_Type")
	if err != nil {
		return err
	}
	*x = Event_Type(value)
	return nil
}
func (Event_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// *
// Scheduler event API.
//
// An event is described using the standard protocol buffer "union"
// trick, see:
// https://developers.google.com/protocol-buffers/docs/techniques#union.
type Event struct {
	// Type of the event, indicates which field below should be
	// present if that type has a nested message definition.
	// Enum fields should be optional, see: MESOS-4997.
	Type             *Event_Type       `protobuf:"varint,1,opt,name=type,enum=scheduler.Event_Type" json:"type,omitempty"`
	Subscribed       *Event_Subscribed `protobuf:"bytes,2,opt,name=subscribed" json:"subscribed,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Event) GetType() Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_UNKNOWN
}

func (m *Event) GetSubscribed() *Event_Subscribed {
	if m != nil {
		return m.Subscribed
	}
	return nil
}

// First event received when the scheduler subscribes.
type Event_Subscribed struct {
	FrameworkId *FrameworkID `protobuf:"bytes,1,req,name=framework_id,json=frameworkId" json:"framework_id,omitempty"`
	// This value will be set if the master is sending heartbeats. See
	// the comment above on 'HEARTBEAT' for more details.
	HeartbeatIntervalSeconds *float64 `protobuf:"fixed64,2,opt,name=heartbeat_interval_seconds,json=heartbeatIntervalSeconds" json:"heartbeat_interval_seconds,omitempty"`
	// Since Mesos 1.1.
	MasterInfo       *MasterInfo `protobuf:"bytes,3,opt,name=master_info,json=masterInfo" json:"master_info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Event_Subscribed) Reset()                    { *m = Event_Subscribed{} }
func (m *Event_Subscribed) String() string            { return proto.CompactTextString(m) }
func (*Event_Subscribed) ProtoMessage()               {}
func (*Event_Subscribed) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Event_Subscribed) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *Event_Subscribed) GetHeartbeatIntervalSeconds() float64 {
	if m != nil && m.HeartbeatIntervalSeconds != nil {
		return *m.HeartbeatIntervalSeconds
	}
	return 0
}

func (m *Event_Subscribed) GetMasterInfo() *MasterInfo {
	if m != nil {
		return m.MasterInfo
	}
	return nil
}

// *
// A unique ID assigned to a framework. A framework can reuse this ID
// in order to do failover (see MesosSchedulerDriver).
type FrameworkID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FrameworkID) Reset()                    { *m = FrameworkID{} }
func (m *FrameworkID) String() string            { return proto.CompactTextString(m) }
func (*FrameworkID) ProtoMessage()               {}
func (*FrameworkID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FrameworkID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Describes a master. This will probably have more fields in the
// future which might be used, for example, to link a framework webui
// to a master webui.
type MasterInfo struct {
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The IP address (only IPv4) as a packed 4-bytes integer,
	// stored in network order.  Deprecated, use `address.ip` instead.
	Ip *uint32 `protobuf:"varint,2,opt,name=ip" json:"ip,omitempty"`
	// The TCP port the Master is listening on for incoming
	// HTTP requests; deprecated, use `address.port` instead.
	Port *uint32 `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	// In the default implementation, this will contain information
	// about both the IP address, port and Master name; it should really
	// not be relied upon by external tooling/frameworks and be
	// considered an "internal" implementation field.
	Pid *string `protobuf:"bytes,4,opt,name=pid" json:"pid,omitempty"`
	// The server's hostname, if available; it may be unreliable
	// in environments where the DNS configuration does not resolve
	// internal hostnames (eg, some public cloud providers).
	// Deprecated, use `address.hostname` instead.
	Hostname *string `protobuf:"bytes,5,opt,name=hostname" json:"hostname,omitempty"`
	// The running Master version, as a string; taken from the
	// generated "master/version.hpp".
	Version *string `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
	// The full IP address (supports both IPv4 and IPv6 formats)
	// and supersedes the use of `ip`, `port` and `hostname`.
	// Since Mesos 0.24.
	Address *Address `protobuf:"bytes,7,opt,name=address" json:"address,omitempty"`
	// The domain that this master belongs to. All masters in a Mesos
	// cluster should belong to the same region.
	Domain           *DomainInfo `protobuf:"bytes,8,opt,name=domain" json:"domain,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *MasterInfo) Reset()                    { *m = MasterInfo{} }
func (m *MasterInfo) String() string            { return proto.CompactTextString(m) }
func (*MasterInfo) ProtoMessage()               {}
func (*MasterInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MasterInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MasterInfo) GetIp() uint32 {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return 0
}

func (m *MasterInfo) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *MasterInfo) GetPid() string {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return ""
}

func (m *MasterInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *MasterInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *MasterInfo) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *MasterInfo) GetDomain() *DomainInfo {
	if m != nil {
		return m.Domain
	}
	return nil
}

// *
// A network address.
//
// TODO(bmahler): Use this more widely.
type Address struct {
	// May contain a hostname, IP address, or both.
	Hostname         *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	Ip               *string `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Port             *int32  `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Address) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Address) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *Address) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

type DomainInfo struct {
	FaultDomain      *DomainInfo_FaultDomain `protobuf:"bytes,1,opt,name=fault_domain,json=faultDomain" json:"fault_domain,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *DomainInfo) Reset()                    { *m = DomainInfo{} }
func (m *DomainInfo) String() string            { return proto.CompactTextString(m) }
func (*DomainInfo) ProtoMessage()               {}
func (*DomainInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DomainInfo) GetFaultDomain() *DomainInfo_FaultDomain {
	if m != nil {
		return m.FaultDomain
	}
	return nil
}

type DomainInfo_FaultDomain struct {
	Region           *DomainInfo_FaultDomain_RegionInfo `protobuf:"bytes,1,opt,name=region" json:"region,omitempty"`
	Zone             *DomainInfo_FaultDomain_ZoneInfo   `protobuf:"bytes,2,opt,name=zone" json:"zone,omitempty"`
	XXX_unrecognized []byte                             `json:"-"`
}

func (m *DomainInfo_FaultDomain) Reset()                    { *m = DomainInfo_FaultDomain{} }
func (m *DomainInfo_FaultDomain) String() string            { return proto.CompactTextString(m) }
func (*DomainInfo_FaultDomain) ProtoMessage()               {}
func (*DomainInfo_FaultDomain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *DomainInfo_FaultDomain) GetRegion() *DomainInfo_FaultDomain_RegionInfo {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *DomainInfo_FaultDomain) GetZone() *DomainInfo_FaultDomain_ZoneInfo {
	if m != nil {
		return m.Zone
	}
	return nil
}

type DomainInfo_FaultDomain_RegionInfo struct {
	Name             *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DomainInfo_FaultDomain_RegionInfo) Reset()         { *m = DomainInfo_FaultDomain_RegionInfo{} }
func (m *DomainInfo_FaultDomain_RegionInfo) String() string { return proto.CompactTextString(m) }
func (*DomainInfo_FaultDomain_RegionInfo) ProtoMessage()    {}
func (*DomainInfo_FaultDomain_RegionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0, 0}
}

func (m *DomainInfo_FaultDomain_RegionInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type DomainInfo_FaultDomain_ZoneInfo struct {
	Name             *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DomainInfo_FaultDomain_ZoneInfo) Reset()         { *m = DomainInfo_FaultDomain_ZoneInfo{} }
func (m *DomainInfo_FaultDomain_ZoneInfo) String() string { return proto.CompactTextString(m) }
func (*DomainInfo_FaultDomain_ZoneInfo) ProtoMessage()    {}
func (*DomainInfo_FaultDomain_ZoneInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0, 1}
}

func (m *DomainInfo_FaultDomain_ZoneInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*Event)(nil), "scheduler.Event")
	proto.RegisterType((*Event_Subscribed)(nil), "scheduler.Event.Subscribed")
	proto.RegisterType((*FrameworkID)(nil), "scheduler.FrameworkID")
	proto.RegisterType((*MasterInfo)(nil), "scheduler.MasterInfo")
	proto.RegisterType((*Address)(nil), "scheduler.Address")
	proto.RegisterType((*DomainInfo)(nil), "scheduler.DomainInfo")
	proto.RegisterType((*DomainInfo_FaultDomain)(nil), "scheduler.DomainInfo.FaultDomain")
	proto.RegisterType((*DomainInfo_FaultDomain_RegionInfo)(nil), "scheduler.DomainInfo.FaultDomain.RegionInfo")
	proto.RegisterType((*DomainInfo_FaultDomain_ZoneInfo)(nil), "scheduler.DomainInfo.FaultDomain.ZoneInfo")
	proto.RegisterEnum("scheduler.Event_Type", Event_Type_name, Event_Type_value)
}

func init() { proto.RegisterFile("scheduler.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xcd, 0x6e, 0xd3, 0x4e,
	0x10, 0xff, 0xaf, 0xf3, 0xe9, 0x71, 0x9b, 0xbf, 0x35, 0xa2, 0xc8, 0x04, 0x09, 0x85, 0x70, 0x09,
	0xa8, 0xe4, 0xd0, 0x03, 0x12, 0x02, 0x21, 0xa5, 0xf5, 0x06, 0x2c, 0x68, 0x8a, 0xd6, 0x09, 0x48,
	0x5c, 0x2c, 0xb7, 0xde, 0x50, 0x8b, 0xc4, 0x6b, 0xad, 0x9d, 0xa0, 0xf2, 0x48, 0xf0, 0x0c, 0x3c,
	0x06, 0x47, 0x8e, 0xbc, 0x07, 0xf2, 0xda, 0x89, 0x5d, 0x52, 0xa9, 0xb7, 0x99, 0xfd, 0x7d, 0x78,
	0xe6, 0x37, 0x32, 0xfc, 0x9f, 0x5c, 0x5c, 0xf2, 0x60, 0xb5, 0xe0, 0x72, 0x18, 0x4b, 0x91, 0x0a,
	0xd4, 0xb7, 0x0f, 0xfd, 0xdf, 0x35, 0x68, 0xd0, 0x35, 0x8f, 0x52, 0x7c, 0x0c, 0xf5, 0xf4, 0x2a,
	0xe6, 0x16, 0xe9, 0x91, 0x41, 0xe7, 0xe8, 0x60, 0x58, 0x8a, 0x14, 0x3e, 0x9c, 0x5e, 0xc5, 0x9c,
	0x29, 0x0a, 0xbe, 0x00, 0x48, 0x56, 0xe7, 0xc9, 0x85, 0x0c, 0xcf, 0x79, 0x60, 0x69, 0x3d, 0x32,
	0x30, 0x8e, 0xee, 0xef, 0x08, 0xdc, 0x2d, 0x85, 0x55, 0xe8, 0xdd, 0x9f, 0x04, 0xa0, 0x84, 0xf0,
	0x39, 0xec, 0xcd, 0xa5, 0xbf, 0xe4, 0x5f, 0x85, 0xfc, 0xe2, 0x85, 0x81, 0x45, 0x7a, 0xda, 0xc0,
	0x38, 0xba, 0x5b, 0x71, 0x1b, 0x6f, 0x60, 0xc7, 0x66, 0xc6, 0x96, 0xeb, 0x04, 0xf8, 0x12, 0xba,
	0x97, 0xdc, 0x97, 0xe9, 0x39, 0xf7, 0x53, 0x2f, 0x8c, 0x52, 0x2e, 0xd7, 0xfe, 0xc2, 0x4b, 0xf8,
	0x85, 0x88, 0x82, 0x44, 0x8d, 0x45, 0x98, 0xb5, 0x65, 0x38, 0x05, 0xc1, 0xcd, 0x71, 0x7c, 0x06,
	0xc6, 0xd2, 0x4f, 0x52, 0x2e, 0xbd, 0x30, 0x9a, 0x0b, 0xab, 0xa6, 0xb6, 0xa8, 0xae, 0x7d, 0xaa,
	0x50, 0x27, 0x9a, 0x0b, 0x06, 0xcb, 0x6d, 0xdd, 0xff, 0x41, 0xa0, 0x9e, 0x65, 0x81, 0x06, 0xb4,
	0x66, 0x93, 0xb7, 0x93, 0xb3, 0x8f, 0x13, 0xf3, 0x3f, 0xec, 0x00, 0xb8, 0xb3, 0x63, 0xf7, 0x84,
	0x39, 0xc7, 0xd4, 0x36, 0x09, 0x02, 0x34, 0xcf, 0xc6, 0x63, 0xca, 0x5c, 0x53, 0x43, 0x84, 0x8e,
	0x33, 0xf9, 0x40, 0x99, 0x4b, 0xbd, 0xe2, 0x4d, 0xcf, 0xc4, 0x8c, 0xba, 0x27, 0xce, 0xc4, 0x36,
	0x6b, 0x78, 0x0f, 0x0e, 0x8a, 0xc6, 0xbb, 0x46, 0x34, 0x21, 0xf3, 0x99, 0xbd, 0xb7, 0x47, 0x53,
	0x6a, 0xd6, 0x33, 0xcd, 0x29, 0x75, 0xdd, 0xd1, 0x6b, 0x6a, 0x36, 0xb2, 0x66, 0x3c, 0x72, 0xde,
	0xcd, 0x18, 0x35, 0x9b, 0xa8, 0x43, 0x83, 0x32, 0x76, 0xc6, 0xcc, 0x16, 0xee, 0x83, 0xfe, 0x86,
	0x8e, 0xd8, 0xf4, 0x98, 0x8e, 0xa6, 0x66, 0xbb, 0xff, 0x08, 0x8c, 0x4a, 0x7e, 0x78, 0x07, 0x1a,
	0x6b, 0x7f, 0xb1, 0xe2, 0x2a, 0x66, 0x9d, 0xe5, 0x4d, 0xff, 0x0f, 0x01, 0x28, 0xb7, 0xc5, 0x0e,
	0x68, 0xea, 0x10, 0x64, 0xa0, 0x33, 0x2d, 0x0c, 0x54, 0x1f, 0xab, 0x3c, 0xf7, 0x99, 0x16, 0xc6,
	0x88, 0x50, 0x8f, 0x85, 0x4c, 0x55, 0x64, 0xfb, 0x4c, 0xd5, 0x68, 0x42, 0x2d, 0x0e, 0x03, 0xab,
	0xae, 0x44, 0x59, 0x89, 0x5d, 0x68, 0x5f, 0x8a, 0x24, 0x8d, 0xfc, 0x25, 0xb7, 0x1a, 0xea, 0x79,
	0xdb, 0xa3, 0x05, 0xad, 0x35, 0x97, 0x49, 0x28, 0x22, 0xab, 0xa9, 0xa0, 0x4d, 0x8b, 0x87, 0xd0,
	0xf2, 0x83, 0x40, 0xf2, 0x24, 0xb1, 0x5a, 0xea, 0x22, 0x58, 0xb9, 0xc8, 0x28, 0x47, 0xd8, 0x86,
	0x82, 0x4f, 0xa1, 0x19, 0x88, 0xa5, 0x1f, 0x46, 0x56, 0x7b, 0xe7, 0x7c, 0xb6, 0x02, 0xd4, 0xf9,
	0x0a, 0x52, 0xdf, 0x81, 0x56, 0x61, 0x71, 0x6d, 0x3a, 0xf2, 0xcf, 0x74, 0xe5, 0xbe, 0xfa, 0xce,
	0xbe, 0x8d, 0x7c, 0xdf, 0xfe, 0x77, 0x0d, 0xa0, 0xfc, 0x02, 0xda, 0xb0, 0x37, 0xf7, 0x57, 0x8b,
	0xd4, 0x2b, 0xc6, 0x21, 0x6a, 0x9c, 0x87, 0x37, 0x8e, 0x33, 0x1c, 0x67, 0xcc, 0xbc, 0x67, 0xc6,
	0xbc, 0x6c, 0xba, 0xbf, 0x08, 0x18, 0x15, 0x10, 0x6d, 0x68, 0x4a, 0xfe, 0x39, 0x4b, 0x29, 0xf7,
	0x3b, 0xbc, 0xd5, 0x6f, 0xc8, 0x14, 0x3f, 0xdf, 0x3a, 0xd7, 0xe2, 0x2b, 0xa8, 0x7f, 0x13, 0x11,
	0x2f, 0xfe, 0xd3, 0x27, 0xb7, 0x7b, 0x7c, 0x12, 0x11, 0x57, 0x0e, 0x4a, 0xd7, 0xed, 0x01, 0x94,
	0xae, 0x59, 0x18, 0x95, 0xd0, 0x54, 0xdd, 0x7d, 0x00, 0xed, 0x8d, 0xe6, 0x26, 0xfc, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x49, 0xaa, 0x26, 0x48, 0x81, 0x04, 0x00, 0x00,
}
